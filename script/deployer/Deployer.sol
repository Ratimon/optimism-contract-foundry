// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


import { Script } from "@forge-std/Script.sol";
import { stdJson } from "@forge-std/StdJson.sol";
import { console2 as console } from "@forge-std/console2.sol";
import { EIP1967Helper } from "test/mocks/EIP1967Helper.sol";
import { IAddressManager } from "@script/interfaces/IAddressManager.sol";
import { LibString } from "@solady/utils/LibString.sol";
import { Executables } from "@script/deployer/Executables.sol";
import { Artifacts, Deployment, DeployerDeployment } from "@script/deployer/Artifacts.s.sol";
import { Config } from "@script/deployer/Config.sol";

import {Vm} from "@forge-std/Vm.sol";
// import "@forge-std/console.sol";
// import "@forge-std/StdJson.sol";


/// @notice Contains information about a storage slot. Mirrors the layout of the storage
///         slot object in Forge artifacts so that we can deserialize JSON into this struct.
struct StorageSlot {
    uint256 astId;
    string _contract;
    string label;
    uint256 offset;
    string slot;
    string _type;
}


interface IDeployer {

    function name() external pure returns (string memory);

    function getStorageLayout(string memory _name) external returns (string memory layout_);

    function loadInitializedSlot(string memory _contractName) external returns (uint8 initialized_);

    /// @notice function that return whether deployments will be broadcasted
    function autoBroadcasting() external returns (bool);

    /// @notice function to activate/deactivate auto-broadcast, enabled by default
    ///  When activated, the deployment will be broadcasted automatically
    ///  Note that if prank is enabled, broadcast will be disabled
    /// @param broadcast whether to acitvate auto-broadcast
    function setAutoBroadcast(bool broadcast) external;

    /// @notice function to activate prank for a given address
    /// @param addr address to prank
    function activatePrank(address addr) external;

    /// @notice function to deactivate prank if any is active
    function deactivatePrank() external;

    /// @notice function that return the prank status
    /// @return active whether prank is active
    /// @return addr the address that will be used to perform the deployment
    function prankStatus() external view returns (bool active, address addr);

    /// @notice function that return all new deployments as an array
    function newDeployments() external view returns (DeployerDeployment[] memory);

    /// @notice allow to override an existing deployment by ignoring the current one.
    /// the deployment will only be overriden on disk once the broadast is performed and `forge-deploy` sync is invoked.
    /// @param name deployment's name to override
    function ignoreDeployment(string memory name) external;

    /// @notice function that tell you whether a deployment already exists with that name
    /// @param name deployment's name to query
    /// @return exists whether the deployment exists or not
    function has(string memory name) external view returns (bool exists);

    /// @notice function that return the address of a deployment
    /// @param name deployment's name to query
    /// @return addr the deployment's address or the zero address
    function getAddress(string memory name) external view returns (address payable addr);

    function mustGetAddress(string memory _name) external view returns (address payable);

    /// @notice function that return the deployment (address, bytecode and args bytes used)
    /// @param name deployment's name to query
    /// @return deployment the deployment (with address zero if not existent)
    function get(string memory name) external view returns (Deployment memory deployment);

    /// @notice Appends a deployment to disk as a JSON deploy artifact.
    /// this is a low level call and is used by ./DefaultDeployerFunction.sol
    /// @param _name deployment's name
    /// @param _deployed address of the deployed contract
    function save(
        string memory _name,
        address _deployed,
        string memory _artifact,
        bytes memory _args,
        bytes memory _bytecode
    ) external;

    function save(string memory _name, address _deployed, string memory _artifact, bytes memory _args) external;

    function save(string memory _name, address _deployed, string memory _artifact) external;

}

abstract contract GlobalDeployer is  IDeployer, Script , Artifacts {
    /// @notice Path to the deploy artifact generated by foundry
    string internal deployPath;

    /// @notice The name of the deploy script that sends the transactions.
    ///         Can be modified with the env var DEPLOY_SCRIPT
    string internal deployScript;

    /// @notice Create the global variables and set up the filesystem.
    ///         Forge script will create a file where the prefix is the
    ///         name of the function that runs with the suffix `-latest.json`.
    ///         By default, `run()` is called. Allow the user to use the SIG
    ///         env var to specify what function signature was called so that
    ///         the `sync()` method can be used to create hardhat deploy style
    ///         artifacts.
    function init() public virtual override {
        Artifacts.init();

        deployScript = Config.deployScript(name());

        string memory sig = Config.sig();
        string memory deployFile = Config.deployFile(sig);
        uint256 chainId = Config.chainID();
        deployPath = string.concat(
            vm.projectRoot(), "/broadcast/", deployScript, ".s.sol/", vm.toString(chainId), "/", deployFile
        );
    }

    /// @notice Returns the name of the deployment script. Children contracts
    ///         must implement this to ensure that the deploy artifacts can be found.
    ///         This should be the same as the name of the script and is used as the file
    ///         name inside of the `broadcast` directory when looking up deployment artifacts.
    function name() public pure virtual returns (string memory);

    /// @notice Returns the storage layout for a deployed contract.
    function getStorageLayout(string memory _name) public override returns (string memory layout_) {
        string[] memory cmd = new string[](3);
        cmd[0] = Executables.bash;
        cmd[1] = "-c";
        cmd[2] = string.concat(Executables.jq, " -r '.storageLayout' < ", _getForgeArtifactPath(_name));
        bytes memory res = vm.ffi(cmd);
        layout_ = string(res);
    }

    /// @dev Returns the value of the internal `_initialized` storage slot for a given contract.
    function loadInitializedSlot(string memory _contractName) public override returns (uint8 initialized_) {
        address contractAddress;
        // Check if the contract name ends with `Proxy` and, if so, get the implementation address
        if (LibString.endsWith(_contractName, "Proxy")) {
            contractAddress = EIP1967Helper.getImplementation(getAddress(_contractName));
            _contractName = LibString.slice(_contractName, 0, bytes(_contractName).length - 5);
            // If the EIP1967 implementation address is 0, we try to get the implementation address from legacy
            // AddressManager, which would work if the proxy is ResolvedDelegateProxy like L1CrossDomainMessengerProxy.
            if (contractAddress == address(0)) {
                contractAddress =
                    IAddressManager(mustGetAddress("AddressManager")).getAddress(string.concat("OVM_", _contractName));
            }
        } else {
            contractAddress = mustGetAddress(_contractName);
        }
        StorageSlot memory slot = getInitializedSlot(_contractName);
        bytes32 slotVal = vm.load(contractAddress, bytes32(vm.parseUint(slot.slot)));
        initialized_ = uint8((uint256(slotVal) >> (slot.offset * 8)) & 0xFF);
    }

    function autoBroadcasting() public override(IDeployer,Artifacts) view returns (bool) {
        return super.autoBroadcasting();
    }

    function setAutoBroadcast(bool broadcast) public override(IDeployer,Artifacts) {
        return super.setAutoBroadcast(broadcast);
    }

    function activatePrank(address addr) public override(IDeployer, Artifacts) {
        return super.activatePrank(addr);
    }

    function deactivatePrank() public override(IDeployer, Artifacts) {
        return super.deactivatePrank();
    }

    function prankStatus() public override(IDeployer, Artifacts) view returns (bool active, address addr) {
        return super.prankStatus();
    }

    function newDeployments() public override(IDeployer, Artifacts) view returns (DeployerDeployment[] memory) {
        return super.newDeployments();
    }

    function ignoreDeployment(string memory _name) public override(IDeployer, Artifacts) {
        return super.ignoreDeployment(_name);
    }

    function has(string memory _name) public override(IDeployer, Artifacts) view returns (bool) {
        return super.has(_name);
    }

    function getAddress(string memory _name) public override(IDeployer,Artifacts) view returns (address payable) {
        return super.getAddress(_name);
    }

    function mustGetAddress(string memory _name) public override(IDeployer,Artifacts) view returns (address payable){
        return super.mustGetAddress(_name);
    }

    function get(string memory _name) public override(IDeployer,Artifacts) view returns (Deployment memory) {
        return super.get(_name);
    }

    function save(
        string memory _name,
        address _deployed,
        string memory _artifact,
        bytes memory _args,
        bytes memory _bytecode
    ) public override(IDeployer,Artifacts) {
        super.save(_name, _deployed,_artifact,_args,_bytecode);
    }

    function save(
        string memory _name,
        address _deployed,
        string memory _artifact,
        bytes memory _args
    ) public override(IDeployer, Artifacts) {
        super.save(_name, _deployed,_artifact,_args);
    }

    function save(
        string memory _name,
        address _deployed,
        string memory _artifact
    ) public override(IDeployer, Artifacts) {
        super.save(_name, _deployed,_artifact);
    }

    /// @notice Removes the semantic versioning from a contract name. The semver will exist if the contract is compiled
    /// more than once with different versions of the compiler.
    function _stripSemver(string memory _name) internal returns (string memory) {
        string[] memory cmd = new string[](3);
        cmd[0] = Executables.bash;
        cmd[1] = "-c";
        cmd[2] = string.concat(
            Executables.echo, " ", _name, " | ", Executables.sed, " -E 's/[.][0-9]+\\.[0-9]+\\.[0-9]+//g'"
        );
        bytes memory res = vm.ffi(cmd);
        return string(res);
    }

    /// @notice Builds the fully qualified name of a contract. Assumes that the
    ///         file name is the same as the contract name but strips semver for the file name.
    function _getFullyQualifiedName(string memory _name) internal returns (string memory) {
        string memory sanitized = _stripSemver(_name);
        return string.concat(sanitized, ".sol:", _name);
    }

    /// @notice Returns the abi from a the forge artifact
    function getAbi(string memory _name) public returns (string memory abi_) {
        string[] memory cmd = new string[](3);
        cmd[0] = Executables.bash;
        cmd[1] = "-c";
        cmd[2] = string.concat(Executables.jq, " -r '.abi' < ", _getForgeArtifactPath(_name));
        bytes memory res = vm.ffi(cmd);
        abi_ = string(res);
    }

    /// @notice Returns the methodIdentifiers from the forge artifact
    function getMethodIdentifiers(string memory _name) public returns (string[] memory ids_) {
        string[] memory cmd = new string[](3);
        cmd[0] = Executables.bash;
        cmd[1] = "-c";
        cmd[2] = string.concat(Executables.jq, " '.methodIdentifiers | keys' < ", _getForgeArtifactPath(_name));
        bytes memory res = vm.ffi(cmd);
        ids_ = stdJson.readStringArray(string(res), "");
    }

    function _getForgeArtifactDirectory(string memory _name) internal returns (string memory dir_) {
        string[] memory cmd = new string[](3);
        cmd[0] = Executables.bash;
        cmd[1] = "-c";
        cmd[2] = string.concat(Executables.forge, " config --json | ", Executables.jq, " -r .out");
        bytes memory res = vm.ffi(cmd);
        string memory contractName = _stripSemver(_name);
        dir_ = string.concat(vm.projectRoot(), "/", string(res), "/", contractName, ".sol");
    }

    /// @notice Returns the filesystem path to the artifact path. If the contract was compiled
    ///         with multiple solidity versions then return the first one based on the result of `ls`.
    function _getForgeArtifactPath(string memory _name) internal returns (string memory) {
        string memory directory = _getForgeArtifactDirectory(_name);
        string memory path = string.concat(directory, "/", _name, ".json");
        if (vm.exists(path)) return path;

        string[] memory cmd = new string[](3);
        cmd[0] = Executables.bash;
        cmd[1] = "-c";
        cmd[2] = string.concat(
            Executables.ls,
            " -1 --color=never ",
            directory,
            " | ",
            Executables.jq,
            " -R -s -c 'split(\"\n\") | map(select(length > 0))'"
        );
        bytes memory res = vm.ffi(cmd);
        string[] memory files = stdJson.readStringArray(string(res), "");
        return string.concat(directory, "/", files[0]);
    }

    /// @notice Returns the forge artifact given a contract name.
    function _getForgeArtifact(string memory _name) internal returns (string memory) {
        string memory forgeArtifactPath = _getForgeArtifactPath(_name);
        return vm.readFile(forgeArtifactPath);
    }

    /// @dev Pulls the `_initialized` storage slot information from the Forge artifacts for a given contract.
    function getInitializedSlot(string memory _contractName) internal returns (StorageSlot memory slot_) {
        string memory storageLayout = getStorageLayout(_contractName);

        string[] memory command = new string[](3);
        command[0] = Executables.bash;
        command[1] = "-c";
        command[2] = string.concat(
            Executables.echo,
            " '",
            storageLayout,
            "'",
            " | ",
            Executables.jq,
            " '.storage[] | select(.label == \"_initialized\" and .type == \"t_uint8\")'"
        );
        bytes memory rawSlot = vm.parseJson(string(vm.ffi(command)));
        slot_ = abi.decode(rawSlot, (StorageSlot));
    }

}

function getGlobalDeployer() returns (IDeployer) {
    //0xD64C5B1F2952CBC28Bd79EB02d3065BbA2696E3A

    // address addr = 0x666f7267652d6465706C6f790000000000000000;
    address addr = address(uint160(uint256(keccak256(abi.encode("optimism.deploy")))));
    if (addr.code.length > 0) {
        return IDeployer(addr);
    }
    Vm vm = Vm(address(bytes20(uint160(uint256(keccak256("hevm cheat code"))))));
    bytes memory code = vm.getDeployedCode("Deployer.sol:GlobalDeployer");
    vm.etch(addr, code);
    vm.allowCheatcodes(addr);
    GlobalDeployer deployer = GlobalDeployer(addr);
    deployer.init();
    return deployer;
}
